# This program is my git fetcher. It's a simple twisted
# application that periodically polls the specified git repos.
# Copyright (C) 2014  Philip Tricca <flihp@twobit.us>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
""" twobit git poller

This tac file defines an application that periodically fetches a
collection of git repos.  Repos are descriped in the accompanying INI-
style configuration file.
"""

from __future__ import print_function

import ast, os, subprocess, sys
from ConfigParser import ConfigParser
from json import load
from twisted.application import service, internet
from twisted.python.log import ILogObserver, FileLogObserver
from twisted.python.logfile import DailyLogFile
from urllib2 import urlopen, URLError

class BuildbotHook(object):
    """ BuildbotHook class
    """

    def __init__(self, script=None, host=None, port=None, user=None,
                 passwd=None, projects=[], logfile=None):
        self.script = script
        self.host = host
        self.port = port
        self.user = user
        self.passwd = passwd
        self.projects = projects
        self.logfile = logfile

class GitFetcher(object):
    """ GitFetcher class
    
    Give this class a URL for a git repo and it will fetch it for you.
    """

    def __init__(self, repo_url = None, basedir = '/tmp', hook=None):
        self.repo_url = repo_url
        self.basedir = basedir
        self.repo_name = self.repo_url.split('/')[-1]
        self.repo_path = self.basedir + '/' + self.repo_name
        self.hook = hook
        # cloning bare repos adds '.git' to end of directory name even if URI
        # doesn't have one
        if self.repo_path[-4:] != '.git':
            self.repo_path = self.repo_path + '.git'

    def _get_branches(self):
        """ Get list of strings representing branches for git repo
        """
        try:
            return subprocess.check_output(
                       ['git', '--git-dir=' + self.repo_path, 'branch']
                   ).decode('utf-8').replace('*', '').split()
        except subprocess.CalledProcessError, e:
            print(e)
            return []

    def _get_symname(self, branch):
        """ Translate a branch name to a string holding full symbolic name
        """
        try:
            return subprocess.check_output(
                       ['git', '--git-dir=' + self.repo_path, 'rev-parse',
                        '--symbolic-full-name', branch]
                   ).decode('utf-8').strip()
        except subprocess.CalledProcessError, e:
            print(e)
            return None

    def _get_hash(self, name):
        """ Get the object hash for named object as string
        """
        try:
            return subprocess.check_output(
                       ['git', '--git-dir=' + self.repo_path, 'rev-parse',
                        name]
                   ).decode('utf-8').strip()
        except subprocess.CalledProcessError, e:
            print(e)
            return None

    def poll(self):
        """ Poll a git repo.
        
        Each call to the 'poll' method will do exactly what you expect:
        the repository will be polled and updated. If the repo exists
        locally it's fetched, otherwised a bare clone is made.
        """
        # sanity check config and directory structure
        if self.repo_url is None:
            print('GitFetcher: no repo url set, nothing to poll.')
            return
        if not os.path.lexists(self.basedir):
            os.mkdir(self.basedir)
        elif not os.path.isdir(self.basedir):
            print('GitFetcher: {0} exists but is not a directory. Aborting'.format(self.basedir))
        hook_data = []
        if (self.hook is not None and 
            self.hook.script is not None and
            os.path.isdir(self.repo_path)):
            # Get hook data before remote update
            branches = self._get_branches()
            for branch in branches:
                # for each branch create tuple of (symname, hash)
                # & add to list
                symname = self._get_symname(branch)
                hook_data.append((symname, self._get_hash(symname)))
        print('for repo {0} at URL {1}: '.format(self.repo_name, self.repo_url), end='')
        try:
            if not os.path.exists(self.repo_path):
                print('cloning mirror into {0}'.format(self.repo_path))
                subprocess.check_output(
                    ['git', 'clone', '--mirror', self.repo_url, self.repo_path],
                    stderr=subprocess.STDOUT
                    )
            elif os.path.isdir(self.repo_path):
                print('updating existing mirror')
                subprocess.check_output(
                    ['git', '--git-dir=' + self.repo_path, 'remote', 'update'],
                    stderr=subprocess.STDOUT
                )
            else:
               print('{0} exists but is not a directory, bad news'.format(self.repo_path))
            print('success polling repo: {0}'.format(self.repo_url))
        except subprocess.CalledProcessError, e:
           print('{0}'.format(e))
        if (self.hook is not None and
            self.hook.script is not None and
            len(hook_data) > 0):
            # Invoke hook script for each project string, can only pass one
            # at a time (I think).
            for project in self.hook.projects:
                p = subprocess.Popen(
                        [self.hook.script,
                         '--master={0}:{1}'.format(self.hook.host,
                                                   self.hook.port),
                         '--username=' + self.hook.user,
                         '--auth=' + self.hook.passwd,
                         '--logfile=' + self.hook.logfile,
                         '--verbose', '--verbose', '--verbose',
                         '--project=' + project
                        ],
                        env={'GIT_DIR' : self.repo_path},
                        stdin=subprocess.PIPE
                    )
                for hook_set in hook_data:
                    post = self._get_hash(hook_set[0])
                    p.stdin.write(
                        '{0} {1} {2}\n'.format(hook_set[1], post, hook_set[0])
                    )
                p.stdin.close()

class GitHubOrgFetcher(object):
    """ Fetch and poll all repos from a GitHub org.
    
    Poll github org finding each repo in the org.  For each repo we
    create a GitFetcher if one doesn't already exit and we create a
    TimeService and hook it up to the supplied application object.
    """
    _GITHUB_REPO_URL = 'https://api.github.com/orgs/{0}/repos'
    def __init__(self, application, orgname, destdir, poll_interval=300):
        self._application = application
        self._destdir = destdir
        self._fetchers = {}
        self._orgname = orgname
        self._poll_interval = poll_interval
        self._url = self._GITHUB_REPO_URL.format(self._orgname)

    def poll(self):
        """ Poll all repos from a GitHub org.
        
        This function operates on data from the constructior.  First
        data about each repo from the specified GitHub org is retrieved
        via the GitHub API. Then a GitFetcher is created for each repo.
        A twisted TimeService with the appropriate poll interval is
        then created for each repo from the org.  Upon subsequent
        invocations new GitFetchers are created for new repos.

        See: https://developer.github.com/v3/repos/
        """ 
        nexturl = self._url
        while nexturl != '':
            print('GitHubOrgFetcher: opening URL: {0}'.format(nexturl))
            try:
                github_req = urlopen(nexturl)
            except URLError as err:
                print('GitHubOrgFetcher: URLError: {0}'.format(err.strerror))
                break

            # Get repos from the JSON body of the request.  If a
            # GitFetcher for this repo doesn't already exist create
            # one.
            for repo in load(github_req):
                if not repo['git_url'] in self._fetchers:
                    print('GitHubOrgFetcher: Creating fetcher for repo: {0}'.format(repo['git_url']))
                    fetcher = self._fetcher_from_github(repo)
                    self._fetchers[repo['git_url']] = fetcher
                    loopreact = internet.TimerService(
                        step = self._poll_interval,
                        callable = fetcher.poll
                    )
                    loopreact.setServiceParent(self._application)
                else:
                    print('GitHubOrgFetcher: fetcher for repo {0} already exists'.format(repo['git_url']))

            # Find the 'next' link from the link header (if it exists).
            # If no 'next' link exists we're at the end of the Org's
            # repos.
            headers = github_req.info()
            for link in headers['link'].split(','):
                link_elements = link.strip().split(';')
                if link_elements[-1].strip() == 'rel="next"':
                    nexturl = link_elements[0].strip(' \t\n\r<>')
                    break
                else:
                    nexturl = ''

    def _fetcher_from_github(self, repo):
        """ Create GitFetcher from GitHub repo dictionary.
        """
        if not 'git_url' in repo:
            sys.exit('Github repo has no git_url?')
        if not os.path.lexists(self._destdir):
            os.makedirs(self._destdir)
        elif not os.path.isdir(self._destdir):
            sys.exit('Required directory {0} for github repo {1} exists but is not a directory.\n'.format(self._destdir, repo['name']))
        print('Creating GitFetcher for {0} in {1}\n'.format(repo['git_url'], self._destdir))
        return GitFetcher(repo['git_url'], self._destdir)

# get application config values
config = ConfigParser()
config.read('@CONFFILE@')
logdir = config.get('DEFAULT', 'logdir')
logfile = config.get('DEFAULT', 'logfile')
# conservative default polling interval
poll_interval_default = 1200

logfile = DailyLogFile(logfile, logdir)
application = service.Application('twobit Git Poller')
application.setComponent(ILogObserver, FileLogObserver(logfile).emit)

# Iterate over repos from config file
for section in config.sections():
    # Get config values, use defaults if necessary.
    config_dict = dict(config.items(section))
    if 'poll-interval' in config_dict:
        poll_interval = float(eval(config_dict['poll-interval']))
    else:
        poll_interval = poll_interval_default
    if not 'basedir' in config_dict:
        sys.exit('Required config item missing from org: basedir\n')
    basedir = config_dict['basedir']
    if 'subdir' in config_dict:
        destdir = basedir + '/' + config_dict['subdir']
    else:
        destdir = basedir
    if ('hook-script' in config_dict and 'hook-master' in config_dict and
        'hook-port' in config_dict and 'hook-user' in config_dict and
        'hook-passwd' in config_dict and 'hook-projects' in config_dict):
        # Get hook script data. Assume all data is required until we find
        # a counter example.
        bb_hook = BuildbotHook(
                      script=config_dict['hook-script'],
                      host=config_dict['hook-master'],
                      port=config_dict['hook-port'],
                      user=config_dict['hook-user'],
                      passwd=config_dict['hook-passwd'],
                      logfile=config_dict['hook-logfile'],
                      projects=ast.literal_eval(config_dict['hook-projects'])
                  )
    else:
        bb_hook = None

    # Create objects to fetch git stuff specific to 'type' from config.
    type = config.get(section, 'type')
    if type == 'git':
        if not 'url' in config_dict:
            sys.exit('Required section missing from git section: url\n')
        fetcher = GitFetcher(repo_url = config_dict['url'],
                             hook = bb_hook,
                             basedir = destdir)
    elif type == 'org':
        # sanity check GitHub org config
        if not 'name' in config_dict:
            sys.exit('Required section missing from org: name\n')
        # make the fetcher
        fetcher = GitHubOrgFetcher(application = application,
                                   orgname = config_dict ['name'],
                                   destdir = destdir,
                                   poll_interval = poll_interval)
    else:
        raise NotImplementedError('Config section type {0} is not implemented.\n'.format(type))
    loopreact = internet.TimerService(step=poll_interval,
                                      callable=fetcher.poll)
    loopreact.setServiceParent(application)

