# This program is my git fetcher. It's a simple twisted
# application that periodically polls the specified git repos.
# Copyright (C) 2014  Philip Tricca <flihp@twobit.us>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
""" twobit git poller

This tac file defines an application that periodically fetches a
collection of git repos.  Repos are descriped in the accompanying INI-
style configuration file.
"""

from __future__ import print_function

import os, subprocess, sys
from ConfigParser import ConfigParser
from json import load
from twisted.application import service, internet
from twisted.python.log import ILogObserver, FileLogObserver
from twisted.python.logfile import DailyLogFile
from urllib2 import urlopen, URLError

class GitFetcher(object):
    """ GitFetcher class
    
    Give this class a URL for a git repo and it will fetch it for you.
    """

    def __init__(self, repo_url = None, basedir = '/tmp'):
        self.repo_url = repo_url
        self.basedir = basedir
        self.repo_name = self.repo_url.split('/')[-1]
        self.repo_path = self.basedir + '/' + self.repo_name
        # cloning bare repos adds '.git' to end of directory name even if URI
        # doesn't have one
        if self.repo_path[-4:] != '.git':
            self.repo_path = self.repo_path + '.git'

    def poll(self):
        """ Poll a git repo.
        
        Each call to the 'poll' method will do exactly what you expect:
        the repository will be polled and updated. If the repo exists
        locally it's fetched, otherwised a bare clone is made.
        """
        if self.repo_url is not None:
            print('fetching repo {0} from URL {1} into {2}'.format(self.repo_name, self.repo_url, self.repo_path))
            try:
                if not os.path.exists(self.repo_path):
                    os.chdir(self.basedir)
                    subprocess.check_output(['git', 'clone', '--bare',
                                            self.repo_url],
                                            stderr=subprocess.STDOUT)
                elif os.path.isdir(self.repo_path):
                    os.chdir(self.repo_path)
                    subprocess.check_output(['git', 'fetch'],
                                            stderr=subprocess.STDOUT)
                    os.chdir(self.basedir)
                else:
                    print('{0} exists but is not a directory, bad news'.format(self.repo_path))
            except subprocess.CalledProcessError, e:
               print('{0}'.format(e))
            print('success polling repo: {0}'.format(self.repo_url))
        else:
            print('no repo url set, nothing to poll')

class GitHubOrgFetcher (object):
    """ Fetch and poll all repos from a GitHub org.
    
    Poll github org finding each repo in the org.  For each repo we
    create a GitFetcher if one doesn't already exit and we create a
    TimeService and hook it up to the supplied application object.
    """
    _GITHUB_REPO_URL = 'https://api.github.com/orgs/{0}/repos'
    def __init__ (self, config, application):
        self._application = application
        self._config = config
        self._fetchers = {}
        self._orgname = config ['name']
        self._poll_interval = float (eval (config ['poll-interval']))
        self._url = self._GITHUB_REPO_URL.format (self._orgname)

    def poll (self):
        """ Poll all repos from a GitHub org.
        
        This function operates on data from the constructior.  First
        data about each repo from the specified GitHub org is retrieved
        via the GitHub API. Then a GitFetcher is created for each repo.
        A twisted TimeService with the appropriate poll interval is
        then created for each repo from the org.  Upon subsequent
        invocations new GitFetchers are created for new repos.

        See: https://developer.github.com/v3/repos/
        """ 
        nexturl = self._url
        while nexturl != '':
            print ('GitHubOrgFetcher: opening URL: {0}\n'.format (nexturl))
            try:
                github_req = urlopen (nexturl)
            except URLError as err:
                print ('GitHubOrgFetcher: URLError: {0}\n'.format (err.strerror))
                break

            # Get repos from the JSON body of the request.  If a
            # GitFetcher for this repo doesn't already exist create
            # one.
            for repo in load (github_req):
                if not repo ['git_url'] in self._fetchers:
                    print ('GitHubOrgFetcher: Creating fetcher for repo: {0}\n'.format (repo ['git_url']))
                    fetcher = fetcher_from_github (self._config, repo)
                    self._fetchers [repo ['git_url']] = fetcher
                    loopreact = internet.TimerService (step = self._poll_interval,
                                                       callable = fetcher.poll)
                    loopreact.setServiceParent (self._application)
                else:
                    print ('GitHubOrgFetcher: fetcher for repo {0} already exists\n'.format (repo ['git_url']))

            # Find the 'next' link from the link header (if it exists).
            # If no 'next' link exists we're at the end of the Org's
            # repos.
            headers = github_req.info ()
            for link in headers ['link'].split (','):
                link_elements = link.strip ().split (';')
                if link_elements[-1].strip () == 'rel="next"':
                    nexturl = link_elements[0].strip (' \t\n\r<>')
                    break
                else:
                    nexturl = ''

def fetcher_from_gitrepo (config, section):
    if not config.has_option (section, 'basedir'):
        sys.exit ('No "basedir" specified. Unable to checkout repo from section: {0}'.format (section))
    basedir = config.get (section, 'basedir')
    if not config.has_option (section, 'url'):
        sys.exit ('Git repo section {0} missing required option "url"\n'.format (section))
    url = config.get (section, 'url')
    logfile.write ('Creating fetcher for git repo named {0} with url {1}\n'.format (section, url))
    if config.has_option (section, 'subdir'):
        destdir = basedir + config.get (section, 'subdir')
    else:
        destdir = basedir
    if not os.path.lexists (destdir):
        os.mkdir (destdir)
    elif not os.path.isdir (destdir):
        sys.exit ('Requested directory in section {0} exists but is not a directory.\n'.format (section))
    return GitFetcher (url, destdir)

def fetcher_from_github (config, repo):
    if not 'basedir' in config:
        sys.exit ('No "basedir" specified. Unable to checkout repo from section: {0}'.format (section))
    if 'subdir' in config:
        destdir = '{0}/{1}'.format (config ['basedir'],
                                    config ['subdir'])
    else:
        destdir = config ['basedir']
    if not 'git_url' in repo:
        sys.exit ('Github repo has no git_url?')
    if not os.path.lexists (destdir):
        os.makedirs (destdir)
    elif not os.path.isdir (destdir):
        sys.exit ('Required directory {0} for github repo {1} exists but is not a directory.\n'.format (destdir, repo ['name']))
    logfile.write ('Creating GitFetcher ({0}, {1}\n'.format (repo ['git_url'], destdir))
    return GitFetcher (repo ['git_url'], destdir)

# get application config values
config = ConfigParser ()
config.read ('@CONFFILE@')
basedir = config.get ('DEFAULT', 'basedir')
logdir = config.get ('DEFAULT', 'logdir')
logfile = config.get ('DEFAULT', 'logfile')
# use eval here to allow intervals like 60*5 to get 5 minutes
poll_interval = float (eval (config.get ('DEFAULT', 'poll-interval')))

logfile = DailyLogFile(logfile, logdir)
application = service.Application('twobit Git Poller')
application.setComponent(ILogObserver, FileLogObserver(logfile).emit)

os.chdir(basedir)
# Iterate over repos from config file
# For each: create GitFetcher that will poll on top level interval
for section in config.sections ():
    type = config.get (section, 'type')
    if type == 'git':
        fetcher = fetcher_from_gitrepo (config, section)
    elif type == 'org':
        github_config = dict (config.items (section))
        if not 'name' in github_config:
            sys.exit ('Required section missing from org: name\n')
        fetcher = GitHubOrgFetcher (github_config, application)
    else:
        raise NotImplementedError ('Config section type {0} is not implemented.\n'.format (type))
    loopreact = internet.TimerService (step=poll_interval,
                                       callable=fetcher.poll)
    loopreact.setServiceParent (application)

